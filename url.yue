--[[
    MIT License

    Copyright (c) 2024 Pika Software

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
--]]
import istable, isnumber, isstring, tostring, tonumber, rawget, rawset, getmetatable from _G
import byte, char, sub, gsub, lower from string
import concat from table

compileCharacterTable = (chars) ->
    result = []
    for v in *chars
        if istable v
            for i = byte(v[1]), byte(v[2])
                result[i] = true
        else
            result[byte(v)] = true
    return result

-- Use result from `compileCharacterTable` in `containsCharacter` as chars
containsCharacter = (str, chars, startPos = 1, endPos = #str) ->
    for i = startPos, endPos
        if chars[byte(str, i)]
            return true
    return false

SPECIAL_SCHEMAS =
    ftp: 21
    file: true -- currently if value is true, then scheme will be treated as file: scheme in the parser
    http: 80
    https: 443
    ws: 80
    wss: 443

FORBIDDEN_HOST_CODE_POINTS = compileCharacterTable [
    "\0", "\t", "\n", "\r"
    " ", "#", "/", ":" 
    "<", ">", "?", "@"
    "[", "\\", "]", "^", "|"
]

FORBIDDEN_DOMAIN_CODE_POINTS = compileCharacterTable [ 
    "\0", "\t", "\n", "\r"
    " ", "#", "/", ":" 
    "<", ">", "?", "@"
    "[", "\\", "]", "^", "|"
    ["\0", "\x1F"], "%", "\x7F"
]

FILE_OTHERWISE_CODE_POINTS = compileCharacterTable [ "/", "\\", "?", "#" ]

DECODE_LOOKUP_TABLE = []
for i = 0x00, 0xFF
    hex = bit.tohex(i, 2)
    DECODE_LOOKUP_TABLE[hex] = char(i)
    DECODE_LOOKUP_TABLE[hex\upper!] = char(i) 

URI_DECODE_SET = {...DECODE_LOOKUP_TABLE}
for i in *[0x2D, 0x2E, 0x21, 0x7E, 0x2A, 0x27, 0x28, 0x29] -- decodeURI doesn't decode these characters: ; / ? : @ & = + $ , #
    hex = bit.tohex(i, 2)
    URI_DECODE_SET[hex] = nil
    URI_DECODE_SET[hex\upper!] = nil

percentDecode = (s, decodeSet) ->
    s = gsub(s, "%%(%x%x)", decodeSet)
    return s

compilePercentEncodeSet = (encodeSet, ...) ->
    -- Lookup table for decoding percent-encoded characters and encoding special characters
    -- Using HEX_TABLE will result in a double speedup compared to using functions
    encodeSet = {...encodeSet} -- copy given encodeSet, so we don't modify it
    for ch in *{...}
        if isstring ch
            ch = byte(ch) -- if string then convert to byte

        if isnumber ch -- just a single character
            encodeSet[char(ch)] = "%" .. bit.tohex(ch, 2)\upper!
        elseif istable ch -- range of characters
            charStart = isstring(ch[1]) and byte(ch[1]) or ch[1]
            charEnd = isstring(ch[2]) and byte(ch[2]) or ch[2]

            for i = charStart, charEnd
                encodeSet[char(i)] = "%" .. bit.tohex(i, 2)\upper!
        
    return encodeSet

percentEncode = (s, encodeSet, spaceAsPlus) ->
    old = nil
    if spaceAsPlus == true
        old = encodeSet[" "]
        encodeSet[" "] = "+"
    s = gsub(s, "%W", encodeSet)
    if old
        encodeSet[" "] = old
    return s

C0_ENCODE_SET = compilePercentEncodeSet({}, [0x00, 0x1F], [0x7F, 0xFF])
FRAGMENT_ENCODE_SET = compilePercentEncodeSet(C0_ENCODE_SET, " ", "\"", "<", ">", "`")
QUERY_ENCODE_SET = compilePercentEncodeSet(C0_ENCODE_SET, " ", "\"", "#", "<", ">")
SPECIAL_QUERY_ENCODE_SET = compilePercentEncodeSet(QUERY_ENCODE_SET, "'")
PATH_ENCODE_SET = compilePercentEncodeSet(QUERY_ENCODE_SET, "?", "`", "{", "}")
USERINFO_ENCODE_SET = compilePercentEncodeSet(PATH_ENCODE_SET, "/", ":", ";", "=", "@", [0x5B, 0x5E], "|")
COMPONENT_ENCODE_SET = compilePercentEncodeSet(USERINFO_ENCODE_SET, [0x24, 0x26], "+", ",")
URLENCODED_ENCODE_SET = compilePercentEncodeSet(COMPONENT_ENCODE_SET, "!", [0x27, 0x29], "~")
URI_ENCODE_SET = compilePercentEncodeSet(C0_ENCODE_SET, 0x20, 0x22, 0x25, 0x3C, 0x3E, [0x42, 0x59], [0x5B, 0x5E], 0x60, [0x62, 0x79], [0x7B, 0x7D])

export encodeURI = (s) -> percentEncode(s, URI_ENCODE_SET)
export encodeURIComponent = (s) -> percentEncode(s, COMPONENT_ENCODE_SET, true)
export decodeURIComponent = (s) -> percentDecode(s, DECODE_LOOKUP_TABLE)
export decodeURI = (s) -> percentDecode(s, URI_DECODE_SET)

isLower = (ch) -> ch >= 0x61 --[['a']] and ch <= 0x7A --[['z']]
isUpper = (ch) -> ch >= 0x41 --[['A']] and ch <= 0x5A --[['Z']]
isAlpha = (ch) -> isLower(ch) or isUpper(ch)
isDigit = (ch) -> ch >= 0x30 --[['0']] and ch <= 0x39 --[['9']]
isSingleDot = (str) ->
    return switch #str
        when 1 then str == "."
        when 3 then lower(str) == "%2e"
        else false
isDoubleDot = (str) ->
    return switch #str
        when 2 then str == ".."
        when 4
            str = lower(str)
            str == "%2e." or str == ".%2e"
        when 6 then lower(str) == "%2e%2e"
        else false
isWindowsDriveLetterCodePoints = (ch1, ch2, normalized) -> isAlpha(ch1) and (ch2 == 0x3A --[[':']] or (normalized == false and ch2 == 0x7C --[['|']]))
isWindowsDriveLetter = (str, normalized) -> return #str == 2 and isWindowsDriveLetterCodePoints(byte(str, 1), byte(str, 2), normalized)
startsWithWindowsDriveLetter = (str, startPos, endPos) ->
    len = endPos - startPos + 1
    return len > 2 and 
        isWindowsDriveLetterCodePoints(byte(str, startPos), byte(str, startPos + 1)) and
        (len == 2 or FILE_OTHERWISE_CODE_POINTS[byte(str, startPos + 2)])

-- Finds nearest non whitespace character from startPos to endPos
-- And returns the position of that character
trimInput = (str, startPos, endPos) ->
    for i = startPos, endPos, (startPos < endPos and 1 or -1)
        ch = byte(str, i)
        if not ch --[[ EOF ]] or ch > 0x20 --[[ C0 control or space ]]
            return i
    return endPos - 1

parseHostString = (str, startPos, endPos, isSpecial) ->
    if byte(str, startPos) == 0x5B -- '['
        if byte(str, endPos) != 0x5D -- ']'
            error "Invalid URL: IPv6 unclosed"

        -- TODO parse ipv6
        return sub(str, startPos + 1, endPos - 1)
    elseif not isSpecial
        -- opaque host parsing
        if containsCharacter(str, FORBIDDEN_HOST_CODE_POINTS, startPos, endPos)
            error "Invalid URL: Host invalid code point"

        return percentEncode(sub(str, startPos, endPos), C0_ENCODE_SET)
    else
        domain = percentDecode(sub(str, startPos, endPos), DECODE_LOOKUP_TABLE)
        asciiDomain = percentEncode(domain, C0_ENCODE_SET) -- TODO punycode encode
        
        if containsCharacter(asciiDomain, FORBIDDEN_DOMAIN_CODE_POINTS)
            error "Invalid URL: Domain invalid code point"
        -- TODO ends in a number + ipv4 parsing

        return domain

-- Predefine locals so we can make functions in the order I want (as if you were reading specs)
local parseScheme, parseNoScheme, parseSpecialRelativeOrAuthority, parsePathOrAuthority
local parseRelative, parseRelativeSlash, parseSpecialAuthorityIgnoreSlashes, parseAuthority
local parseHost, parsePort, parseFile, parseFileSlash, parseFileHost, parsePathStart, parsePath, parseOpaquePath
local parseQuery, parseFragment

parseScheme = (str, startPos, endPos, base, stateOverride) =>
    -- scheme start state
    if isAlpha byte(str, startPos)
        -- scheme state
        doLowerCase = false
        scheme = nil
        for i = startPos, endPos
            ch = byte(str, i)
            if ch == 0x3A -- ':'
                scheme = sub(str, startPos, i - 1)
                if doLowerCase
                    scheme = lower(scheme)
                
                isSpecial = SPECIAL_SCHEMAS[scheme]
                if stateOverride
                    isUrlSpecial = @scheme and SPECIAL_SCHEMAS[@scheme]
                    if isUrlSpecial and not isSpecial then return
                    if not isUrlSpecial and isSpecial then return
                    if @username or @password or @port and isSpecial == true then return
                    if isUrlSpecial == true and not @hostname == "" then return

                @scheme = scheme

                if stateOverride
                    if @port == isSpecial
                        @port = nil
                elseif isSpecial == true -- scheme is file:
                    -- file state
                    parseFile(@, str, i + 1, endPos, base)
                elseif isSpecial and base and base.scheme == scheme
                    -- special relative or authority state
                    parseSpecialRelativeOrAuthority(@, str, i + 1, endPos, base, isSpecial)
                elseif isSpecial
                    -- special authority slashes state
                    parseSpecialAuthorityIgnoreSlashes(@, str, i + 1, endPos, base, isSpecial) -- anyway state will ignore slashes
                elseif byte(str, i + 1) == 0x2F --[['/']]
                    -- path or authority state
                    parsePathOrAuthority(@, str, i + 2, endPos, base)
                else
                    -- opaque path state
                    parseOpaquePath(@, str, i + 1, endPos)
                return
            elseif isUpper(ch)
                doLowerCase = true
            elseif not isLower(ch) and ch != 0x2B --[['+']] and ch != 0x2D --[['-']] and ch != 0x2E --[['.']]
                -- scheme have an invalid character, so it's not a scheme
                break

    if not stateOverride
        -- no scheme state
        parseNoScheme(@, str, startPos, endPos, base)

parseNoScheme = (str, startPos, endPos, base) =>
    startsWithFragment = byte(str, startPos) == 0x23 --[['#']]
    baseHasOpaquePath = base and isstring(base.path)
    if not base or (baseHasOpaquePath and not startsWithFragment)
        error "Invalid URL: Missing scheme"

    if baseHasOpaquePath and startsWithFragment
        @scheme = base.scheme
        @path = base.path
        @query = base.query
        parseFragment(@, str, startPos + 1, endPos)
    elseif base.scheme != "file"
        parseRelative(@, str, startPos, endPos, base)
    else
        @scheme = "file"
        parseFile(@, str, startPos, endPos, base)

parseSpecialRelativeOrAuthority = (str, startPos, endPos, base, isSpecial) =>
    if byte(str, startPos) == 0x2F --[['/']] and byte(str, startPos + 1) == 0x2F --[['/']]
        -- special authority slashes state
        parseSpecialAuthorityIgnoreSlashes(@, str, startPos + 2, endPos, base, isSpecial)
    else
        -- relative state
        @scheme = base.scheme
        parseRelative(@, str, startPos, endPos, base, isSpecial)

parsePathOrAuthority = (str, startPos, endPos, base) =>
    if byte(str, startPos) == 0x2F --[['/']]
        parseAuthority(@, str, startPos + 1, endPos)
    else
        parsePath(@, str, startPos, endPos)

parseRelative = (str, startPos, endPos, base, isSpecial) =>
    ch = byte(str, startPos)
    if ch == 0x2F --[['/']] or (isSpecial and ch == 0x5C --[['\']])
        -- relative slash state
        parseRelativeSlash(@, str, startPos + 1, endPos, base, isSpecial)
    else
        @username = base.username
        @password = base.password
        @hostname = base.hostname
        @port = base.port
        path = @path = {...base.path} -- clone path
        if ch == 0x3F --[['?']]
            parseQuery(@, str, startPos + 1, endPos)
        elseif ch == 0x23 --[['#']]
            @query = base.query
            parseFragment(@, str, startPos + 1, endPos)
        elseif ch -- not EOF
            pathLen = #path
            if pathLen != 1 or not isWindowsDriveLetter(path[1])
                path[pathLen] = nil -- removing last path segment
            parsePath(@, str, startPos, endPos, isSpecial, path)


parseRelativeSlash = (str, startPos, endPos, base, isSpecial) =>
    ch = byte(str, startPos)
    if isSpecial and (ch == 0x2F --[['/']] or ch == 0x5C --[['\']])
        -- special authority ignore slashes state
        parseSpecialAuthorityIgnoreSlashes(@, str, startPos + 1, endPos, base, isSpecial)
    elseif ch == 0x2F --[['/']]
        -- authority state
        parseAuthority(@, str, startPos + 1, endPos, isSpecial)
    else
        @username = base.username
        @password = base.password
        @hostname = base.hostname
        @port = base.port
        parsePath(@, str, startPos, endPos, isSpecial)

parseSpecialAuthorityIgnoreSlashes = (str, startPos, endPos, base, isSpecial) =>
    for i = startPos, endPos
        ch = byte(str, i)
        if ch != 0x2F --[['/']] and ch != 0x5C --[['\']]
            parseAuthority(@, str, i, endPos, isSpecial)
            break

parseAuthority = (str, startPos, endPos, isSpecial) =>
    -- authority state
    atSignSeen = false
    passwordTokenSeen = false
    for i = startPos, endPos
        ch = byte(str, i)
        if ch == 0x2F --[['/']] or ch == 0x3F --[['?']] or ch == 0x23 --[['#']] or (isSpecial and ch == 0x5C --[['\']])
            endPos = i - 1
            break
        elseif ch == 0x40 -- '@'
            atSignSeen = i
        elseif ch == 0x3A --[[':']] and not passwordTokenSeen
            passwordTokenSeen = i
    
    -- After @ there is no hostname
    if atSignSeen == endPos
        error "Invalid URL: Missing host"

    if atSignSeen
        if passwordTokenSeen
            @username = percentEncode(sub(str, startPos, passwordTokenSeen - 1), USERINFO_ENCODE_SET)
            @password = percentEncode(sub(str, passwordTokenSeen + 1, atSignSeen - 1), USERINFO_ENCODE_SET)
        else
            @username = percentEncode(sub(str, startPos, atSignSeen - 1), USERINFO_ENCODE_SET)

    parseHost(@, str, atSignSeen and atSignSeen + 1 or startPos, endPos, isSpecial)
    parsePathStart(@, str, endPos + 1, endPos, isSpecial)

parseHost = (str, startPos, endPos, isSpecial, stateOverride) =>
    if stateOverride and isSpecial == true
        return parseFileHost(@, str, startPos, endPos, stateOverride)

    insideBrackets = false
    for i = startPos, endPos
        ch = byte(str, i)
        if ch == 0x3A --[[':']] and not insideBrackets
            if i == startPos
                error "Invalid URL: Missing host"
            if stateOverride == "hostname"
                return
        
            parsePort(@, str, i + 1, endPos, isSpecial, stateOverride)

            endPos = i - 1
            break
        elseif ch == 0x5B -- '['
            insideBrackets = true
        elseif ch == 0x5D -- ']'
            insideBrackets = false

    if isSpecial and startPos == endPos
        error "Invalid URL: Missing host"
    elseif stateOverride and startPos == endPos and (@username or @password or @port)
        return

    @hostname = parseHostString(str, startPos, endPos, isSpecial)

parsePort = (str, startPos, endPos, defaultPort, stateOverride) =>
    port = tonumber sub(str, startPos, endPos)
    if not port or (port > 2 ^ 16 - 1) or port < 0
        if stateOverride then 
            return
        error "Invalid URL: Invalid port"
    
    if port != defaultPort
        @port = port

parseFile = (str, startPos, endPos, base) =>
    ch = byte(str, startPos)
    if ch == 0x2F --[['/']] or ch == 0x5C --[['\']]
        parseFileSlash(@, str, startPos + 1, endPos, base)
    elseif base and base.scheme == "file"
        @hostname = base.hostname
        path = @path = {...base.path}
        if ch == 0x3F --[['?']]
            parseQuery(@, str, startPos + 1, endPos)
        elseif ch == 0x23 --[['#']]
            @query = base.query
            parseFragment(@, str, startPos + 1, endPos)
        elseif ch -- not EOF
            pathLen = #path
            if not startsWithWindowsDriveLetter(str, startPos, endPos)
                if pathLen != 1 or not isWindowsDriveLetter(path[1])
                    path[pathLen] = nil -- removing last path segment
            else
                path = nil
            parsePath(@, str, startPos, endPos, true, path)
    else
        parsePath(@, str, startPos, endPos, true)

parseFileSlash = (str, startPos, endPos, base) =>
    ch = byte(str, startPos)
    if ch == 0x2F --[['/']] or ch == 0x5C --[['\']]
        parseFileHost(@, str, startPos + 1, endPos)
    else
        path = {}
        if base and base.scheme == "file"
            @hostname = base.hostname
            if not startsWithWindowsDriveLetter(str, startPos, endPos) and isWindowsDriveLetter(base.path[1], false)
                path[1] = base.path[1]
        parsePath(@, str, startPos, endPos, true, path)

parseFileHost = (str, startPos, endPos, stateOverride) =>
    i = startPos
    while true
        ch = byte(str, i)
        if ch == 0x2F --[['/']] or ch == 0x5C --[['\']] or ch == 0x3F --[['?']] or ch == 0x23 --[['#']] or not ch -- EOF
            hostLen = i - startPos
            if not stateOverride and hostLen == 2 and isWindowsDriveLetterCodePoints(byte(str, startPos), byte(str, startPos + 1), false)
                parsePath(@, str, startPos, endPos, true)
            elseif hostLen == 0
                @hostname = ""
                if stateOverride
                    return
                
                parsePathStart(@, str, i, endPos, true)
            else
                hostname = parseHostString(str, startPos, i - 1, false)
                if hostname == "localhost"
                    hostname = ""
                
                @hostname = hostname
                if stateOverride
                    return
                
                parsePathStart(@, str, i, endPos, true)
            break
        i += 1

parsePathStart = (str, startPos, endPos, isSpecial, stateOverride) =>
    ch = byte(str, startPos)
    if isSpecial
        if ch == 0x2F --[['/']] or ch == 0x5C --[['\']]
            startPos += 1
        parsePath(@, str, startPos, endPos, isSpecial, nil, stateOverride)
    elseif not stateOverride and ch == 0x3F --[['?']]
        parseQuery(@, str, startPos + 1, endPos)
    elseif not stateOverride and ch == 0x23 --[['#']]
        parseFragment(@, str, startPos + 1, endPos)
    elseif ch -- not EOF
        if ch == 0x2F --[['/']]
            startPos += 1
        parsePath(@, str, startPos, endPos, isSpecial, nil, stateOverride)
    elseif stateOverride and not @hostname
        @path[] = "" -- append empty string to path

parsePath = (str, startPos, endPos, isSpecial, segments={}, stateOverride) =>
    hasWindowsLetter = false
    segmentsCount = #segments
    segmentStart = startPos

    i = startPos
    while true
        ch = byte(str, i)
        if ch == 0x2F --[['/']] or (isSpecial and ch == 0x5C --[['\']]) or (not stateOverride and (ch == 0x3F --[['?']] or ch == 0x23 --[['#']])) or not ch -- EOF
            segment = percentEncode(sub(str, segmentStart, i - 1), PATH_ENCODE_SET)
            segmentStart = i + 1
            if isDoubleDot(segment)
                if segmentsCount != 1 or not hasWindowsLetter
                    segments[segmentsCount] = nil
                    segmentsCount -= 1
            elseif not isSingleDot(segment)
                if isSpecial == true --[[is file scheme]] and segmentsCount == 0 and isWindowsDriveLetter(segment, false)
                    segment = gsub(segment, "|", ":")
                    hasWindowsLetter = true
                segmentsCount += 1
                segments[segmentsCount] = segment

            if ch == 0x3F --[['?']]
                parseQuery(@, str, i + 1, endPos)
                break
            elseif ch == 0x23 --[['#']]
                parseFragment(@, str, i + 1, endPos)
                break
            elseif not ch
                break

        i += 1

    @path = segments

parseOpaquePath = (str, startPos, endPos) =>
    for i = startPos, endPos
        ch = byte(str, i)
        if ch == 0x3F --[['?']]
            parseQuery(@, str, i + 1, endPos)
            endPos = i - 1
            break
        elseif ch == 0x23 --[['#']]
            parseFragment(@, str, i + 1, endPos)
            endPos = i - 1
            break

    @path = percentEncode(sub(str, startPos, endPos), C0_ENCODE_SET)

parseQuery = (str, startPos, endPos, isSpecial, stateOverride) =>
    for i = startPos, endPos
        if not stateOverride and byte(str, i) == 0x23 --[['#']]
            parseFragment(@, str, i + 1, endPos)
            endPos = i - 1
            break

    encodeSet = isSpecial and SPECIAL_QUERY_ENCODE_SET or QUERY_ENCODE_SET
    @query = percentEncode(sub(str, startPos, endPos), encodeSet)

parseFragment = (str, startPos, endPos) =>
    @fragment = percentEncode(sub(str, startPos, endPos), FRAGMENT_ENCODE_SET)

export parse = (str, base) =>
    unless isstring str
        error "Invalid URL: URL must be a string"
    
    if isstring base
        -- yeah, we dont even need to full URL object for this
        url = {}
        parse(url, base)
        base = url

    str = gsub(str, "[\t\n\r]", "") -- remove all tab and newline characters
    startPos = 1
    endPos = #str

    -- Trim leading and trailing whitespaces
    startPos = trimInput(str, startPos, endPos)
    endPos = trimInput(str, endPos, startPos)

    if startPos > endPos
        error "Invalid URL: Empty URL"

    parseScheme(@, str, startPos, endPos, base)

export serialize = (excludeFragment) =>
    scheme = @scheme
    hostname = @hostname
    path = @path
    query = @query
    fragment = @fragment
    isOpaque = isstring(path)

    output = []
    if scheme
        output[] = scheme
        output[] = ":"
    if hostname
        output[] = "//"
        username = @username
        password = @password
        if username or password
            output[] = username
            if password and password != ""
                output[] = ":"
                output[] = password
            output[] = "@"
        output[] = hostname
        if port := @port
            output[] = ":"
            output[] = tostring(port)
    elseif path and not isOpaque and #path > 1 and path[1] == ""
        output[] = "./"

    if path
        output[] = isOpaque and path or "/" .. concat(path, "/")
    
    if query
        output[] = "?"
        output[] = query
    
    if fragment and excludeFragment != true
        output[] = "#"
        output[] = fragment

    return concat(output, "")

getOrigin = =>
    switch @scheme
        when "ftp", "http", "https", "ws", "wss"
            return @scheme, @hostname, @port
        -- otherwise it is opaque

serializeOrigin = =>
    scheme, hostname, port = getOrigin()
    if scheme
        output = scheme .. "://" .. hostname
        if port
            output = output .. ":" .. port
        return output

serializeHost = (host) ->
    return host -- TODO

export class URL
    new: (str, base) =>
        state = @state = {}
        parse(state, str, base)

    @parse: (str, base) -> URL(str, base)
    @canParse: (str, base) -> pcall(parse, {}, str, base)

    STATE_FIELDS = {"scheme": true, "username": true, "password": true, "hostname": true, "port": true, "path": true, "query": true, "fragment": true}

    resetCache = () =>
        rawset(@, "_href", nil)
        rawset(@, "_origin", nil)
        rawset(@, "_host", nil)
        rawset(@, "_hostname", nil)
        rawset(@, "_pathname", nil)

    cacheValue = (key, value) =>
        rawset(@, key, value)
        return value

    __index: (key) =>
        state = rawget(@, "state")

        -- State fields
        if STATE_FIELDS[key]
            switch key
                when "hostname" then return rawget(@, "_hostname") or cacheValue(@, "_hostname", serializeHost(state.hostname))
                else return state[key]

        -- Special fields
        return switch key
            when "href" then return rawget(@, "_href") or cacheValue(@, "_href", serialize(state))
            when "origin" then return rawget(@, "_origin") or cacheValue(@, "_origin", serializeOrigin(state))
            when "protocol" then return state.scheme and state.scheme .. ":" or nil
            when "host"
                if cached := rawget(@, "_host") then return cached
                if not state.hostname then return ""
                return cacheValue(@, "_host", state.port and @hostname .. ":" .. state.port or @hostname)
            when "pathname"
                if cached := rawget(@, "_pathname") then return cached
                if not istable(state.path) then return state.path
                return cacheValue(@, "_pathname", "/" .. concat(state.path, "/"))
            when "search"
                if not state.query or state.query == "" then return ""
                return "?" .. state.query
            when "searchParams" then return -- TODO
            when "hash"
                if not state.fragment or state.fragment == "" then return ""
                return "#" .. state.fragment
            else return rawget(@, key)

    __newindex: (key, value) =>
        state = rawget(@, "state")

        -- State fields
        if STATE_FIELDS[key]
            resetCache()
            switch key
                when "username"
                    if not state.hostname or state.hostname == "" or state.scheme == "file"
                        return
                    state.username = value
                when "password"
                    if not state.hostname or state.hostname == "" or state.scheme == "file"
                        return
                    state.password = value
                when "hostname"
                    if isstring(state.path)
                        return
                    resetCache()
                    parseHost(state, value, 1, #value, state.scheme and SPECIAL_SCHEMAS[state.scheme], "hostname")
                when "port"
                    if not state.hostname or state.hostname == "" or state.scheme == "file"
                        return

                    resetCache()
                    if not value or value == ""
                        state.port = nil
                        return
                    else
                        value = tostring(value)
                        parsePort(state, value, 1, #value, state.scheme and SPECIAL_SCHEMAS[state.scheme], true)
                else state[key] = value
            return

        -- Special fields
        switch key
            when "href"
                resetCache()
                state = {}
                parse(state, value)
                rawset(@, "state", state)
            when "origin" then return -- readonly field
            when "protocol"
                resetCache()
                parseScheme(state, value, 1, #value, nil, true)
            when "host"
                if isstring(state.path)
                    return
                resetCache()
                parseHost(state, value, 1, #value, state.scheme and SPECIAL_SCHEMAS[state.scheme], "host")
            when "pathname"
                if isstring(state.path)
                    return
                resetCache()
                path = {}
                parsePathStart(state, value, 1, #value, state.scheme and SPECIAL_SCHEMAS[state.scheme], true)
            when "search"
                resetCache()
                leadingSymbol = byte(value, 1) == 0x3F --[['?']]
                parseQuery(state, value, leadingSymbol and 2 or 1, #value, state.scheme and SPECIAL_SCHEMAS[state.scheme], true)
            when "hash"
                if not value or value == ""
                    state.fragment = nil
                    return
                resetCache()
                leadingSymbol = byte(value, 1) == 0x23 --[['#']]
                parseFragment(state, value, leadingSymbol and 2 or 1, #value)
            else rawset(@, key, value)
