--[[
    MIT License

    Copyright (c) 2024 Pika Software

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
--]]
import istable, isnumber, isstring, tostring, tonumber, rawget, rawset, getmetatable from _G
import byte, char, sub, gsub, match, find, lower, Split from string
import concat, insert, remove from table

CERTAINLY_NOT_NESTED = false
MIGHT_BE_NESTED = true

COMMA = 0x2C -- ,
EQUALS = 0x3D -- =
PCT = 0x25 -- %
LEFT = 0x5B -- [
RIGHT = 0x5D -- ]
AMP = 0x26 -- &
PLUS = 0x2B -- +
INT_START = 0x30 -- 0
INT_END = 0x39 -- 10

compileCharacterTable = (chars) ->
    result = []
    for v in *chars
        if istable v
            for i = byte(v[1]), byte(v[2])
                result[i] = true
        else
            result[byte(v)] = true
    return result

-- Use result from `compileCharacterTable` in `containsCharacter` as chars
containsCharacter = (str, chars, startPos = 1, endPos = #str) ->
    for i = startPos, endPos
        if chars[byte(str, i)]
            return true
    return false

SPECIAL_SCHEMAS =
    ftp: 21
    file: true
    http: 80
    https: 443
    ws: 80
    wss: 443

FORBIDDEN_HOST_CODE_POINTS = compileCharacterTable [
    "\0", "\t", "\n", "\r"
    " ", "#", "/", ":" 
    "<", ">", "?", "@"
    "[", "\\", "]", "^", "|"
]

FORBIDDEN_DOMAIN_CODE_POINTS = compileCharacterTable [ 
    "\0", "\t", "\n", "\r"
    " ", "#", "/", ":" 
    "<", ">", "?", "@"
    "[", "\\", "]", "^", "|"
    ["\0", "\x1F"], "%", "\x7F"
]

-- Lookup table for decoding percent-encoded characters and encoding special characters
-- Using HEX_TABLE will result in a double speedup compared to using functions
HEX_TABLE = []
for i = 0x00, 0xFF
    hex = bit.tohex(i, 2)
    HEX_TABLE[hex] = char(i)
    HEX_TABLE[hex\upper!] = char(i)
    HEX_TABLE[char(i)] = "%" .. hex\upper!

-- Special characters
HEX_TABLE["\r\n"] = "\n"
HEX_TABLE[" "] = "+"
HEX_TABLE["-"] = "-"
HEX_TABLE["."] = "."
HEX_TABLE["_"] = "_"
HEX_TABLE["~"] = "~"
HEX_TABLE["!"] = "!"
HEX_TABLE["*"] = "*"
HEX_TABLE["'"] = "'"
HEX_TABLE["("] = "("
HEX_TABLE[")"] = ")"

export decodeURI = (s) ->
    s = gsub(s, "%%(%x%x)", HEX_TABLE) |> gsub("+", " ")
    return s

export encodeURI = (s) ->
    s = gsub(s, "%W", HEX_TABLE)
    return s

isLower = (ch) -> ch >= 0x61 --[['a']] and ch <= 0x7A --[['z']]
isUpper = (ch) -> ch >= 0x41 --[['A']] and ch <= 0x5A --[['Z']]
isAlpha = (ch) -> isLower(ch) or isUpper(ch)
isDigit = (ch) -> ch >= 0x30 --[['0']] and ch <= 0x39 --[['9']]

-- https://github.com/petkaantonov/querystringparser
export class QueryStringParser
    maxLength: 32768
    maxDepth: 4
    maxKeys: 256

    parse: (str) =>
        @containsSparse = false
        @cacheKey = ""
        @cacheVal = nil

        if isstring(str)
            if #str > @maxLength
                error "str is too large (QueryStringParser.maxLength=" .. @maxLength .. ")"

            return @parseString(str, false)
        elseif istable(str)
            error "not implemented"

        return {}

    stringify: (obj) =>
        unless istable(obj)
            error "obj must be a table"

        keyPrefix = ""
        cur = obj
        key = nil
        value = nil
        isArray = false -- please do not pass array as first argument :)
        stack = []
        stackLen = 0
        ret, length = {}, 0

        -- spooky spooky while true loop :)
        while true
            if isArray
                key += 1
                value = cur[key]
                unless value
                    key = nil
            else
                key, value = next(cur, key)

            if key != nil
                serializedKey = encodeURI( isArray and tostring(key - 1) or tostring(key) )
                if istable(value)
                    stack[stackLen + 1] = keyPrefix
                    stack[stackLen + 2] = cur
                    stack[stackLen + 3] = key
                    stack[stackLen + 4] = isArray
                    stackLen += 4

                    keyPrefix = keyPrefix == "" and serializedKey or keyPrefix .. "[" .. serializedKey .. "]"
                    isArray = value[1] and true or false -- usually this is enough to determine if table is an array
                    key = isArray and 0 or nil
                    cur = value
                else
                    serializedKey = keyPrefix == "" and serializedKey or keyPrefix .. "[" .. serializedKey .. "]"
                    length += 1
                    ret[length] = serializedKey .. "=" .. encodeURI(value)
            elseif stackLen != 0
                keyPrefix = stack[stackLen - 3]
                cur = stack[stackLen - 2]
                key = stack[stackLen - 1]
                isArray = stack[stackLen]
                stackLen -= 4
            else
                break

        return concat(ret, "&", 1, length)


    decode: (str, shouldDecode, containsPlus) =>
        unless shouldDecode
            return str

        if containsPlus
            str = gsub(str, "%+", " ")

        return decodeURI(str)

    maybeArrayIndex: (str, arrayLength) =>
        length = #str
        -- Empty string I.E. direct brackets [] means index will be .length
        if length == 0
            return arrayLength

        ch = byte(str, 1)

        -- "0" is only valid index if it's the only character in the string
        -- "00", "001", are not valid array indices
        if ch == INT_START
            return length > 1 and -1 or 1

        if INT_START <= ch and ch <= INT_END
            -- Single digit number 1-9
            if length == 1
                return ch - INT_START + 1
            elseif match(str, "^%d+$")
                return tonumber(str) + 1

        return -1

    getSlot: (dictonary, prevKey, curKey) =>
        unless dictonary[prevKey]
            dictonary[prevKey] = {}

        return dictonary[prevKey]

    placeNestedValue: (dictonary, key, value, i, prevKey, curKey) =>
        slot = @getSlot(dictonary, prevKey, curKey)
        index = @maybeArrayIndex(curKey, #slot)

        length = #key
        depth = 2
        maxDepth = @maxDepth
        start = -1

        while (i <= length)
            ch = byte(key, i)
            if ch == LEFT
                start = i + 1
            elseif ch == RIGHT and start != -1
                prevKey = curKey
                curKey = start == i and "" or sub(key, start, i - 1)
                start = -1
                depth += 1

                if depth > maxDepth
                    error "too deep (QueryStringParser.maxDepth=" .. maxDepth .. ")"

                slot = @getSlot(slot, prevKey, curKey)
                index = @maybeArrayIndex(curKey, #slot)

            i += 1

        if index != -1
            if value != ""
                nextIndex = #slot + 1
                if index == nextIndex
                    slot[nextIndex] = value
                else
                    @containsSparse = true
                    slot[index] = value
        else
            @insert(slot, curKey, value)

    insert: (dictonary, key, value) =>
        if prev := dictonary[key]
            if istable(prev)
                prev[] = value
                return prev

            new = [prev, value]
            dictonary[key] = new
            return new

        dictonary[key] = value

    push: (dictonary, key, value) =>
        if prev := dictonary[key]
            prev[] = value
            return prev

        new = {value}
        dictonary[key] = new
        return new

    maybePlaceNestedValue: (dictonary, key, value) =>
        len = #key
        if byte(key, len) != RIGHT
            @placeValue(dictonary, key, value, CERTAINLY_NOT_NESTED)
            return

        start = -1
        i = 1
        curKey = nil
        prevKey = nil

        while i <= len
            ch = byte(key, i)
            if ch == LEFT
                start = i + 1
                prevKey = sub(key, 1, i - 1)
            elseif ch == RIGHT
                if start == -1
                    @placeValue(dictonary, key, value, CERTAINLY_NOT_NESTED)
                    return

                curKey = start == i and "" or sub(key, start, i - 1)
                i += 1
                break

            i += 1

        if curKey == nil
            @placeValue(dictonary, key, value, CERTAINLY_NOT_NESTED)
            return

        if curKey == "" and value != "" and i == len
            if key == @cacheKey
                @cacheValue[] = value
            else
                @cacheKey = key
                @cacheValue = @push(dictonary, prevKey, value)
        else
            @placeNestedValue(dictonary, key, value, i, prevKey, curKey)

    placeValue: (dictonary, key, value, possiblyNested) =>
        if possiblyNested == MIGHT_BE_NESTED
            @maybePlaceNestedValue(dictonary, key, value)
            return

        if key == @cacheKey
            @cacheValue[] = value
            return

        if cache := @insert(dictonary, key, value)
            @cacheKey = key
            @cacheValue = cache

    compact: (obj) =>
        unless istable(obj)
            return obj

        if obj[1] -- probably an array
            ret, length = [], 0
            for _, v in pairs obj
                length += 1
                ret[length] = v

            return ret

        for k, v in pairs obj
            obj[k] = @compact(v)

        return obj


    parseString: (str, noDecode) =>
        keys = 0
        decodeKey = false
        decodeValue = false
        possiblyNested = CERTAINLY_NOT_NESTED
        len = #str
        i = 1
        dictonary = {}
        keyStart = 1
        keyEnd = 1
        valueStart = 1
        valueEnd = 1
        left = 0
        containsPlus = false

        while i <= len
            ch = byte(str, i)

            if ch == LEFT
                left += 1
            elseif left > 0 and ch == RIGHT
                possiblyNested = MIGHT_BE_NESTED
                left -= 1
            elseif left == 0 and ch == EQUALS
                keyEnd = i - 1
                valueEnd = valueStart = i + 1
                key = @decode(sub(str, keyStart, keyEnd), decodeKey, containsPlus)
                decodeKey = false

                for j = valueStart, len
                    ch = byte(str, j)

                    if (ch == PLUS or ch == PCT) and not noDecode
                        if ch == PLUS then containsPlus = true
                        decodeValue = true

                    if ch == AMP or j == len
                        valueEnd = j
                        i = j

                        if ch == AMP
                            valueEnd -= 1

                        value = sub(str, valueStart, valueEnd)
                        value = @decode(value, decodeValue, containsPlus)

                        -- Place value
                        @placeValue(dictonary, key, value, possiblyNested)

                        containsPlus = decodeValue = false
                        possiblyNested = CERTAINLY_NOT_NESTED

                        keyStart = j + 1
                        keys += 1

                        if (keys > @maxKeys)
                            error "too many keys (QueryStringParser.maxKeys=" .. @maxKeys .. ")"

                        break

            elseif (ch == PLUS or ch == PCT) and not noDecode
                if ch == PLUS then containsPlus = true
                decodeKey = true

            i += 1

        if keyStart < len
            key = @decode(sub(str, keyStart, len), decodeKey, containsPlus)
            @placeValue(dictonary, key, "", possiblyNested)

        if @containsSparse
            -- original developer once said
            -- This behavior is pretty stupid but what you gonna do
            @compact(dictonary)

        return dictonary

class URL
    new: =>
        @scheme = nil
        @username = nil
        @password = nil
        @hostname = nil
        @pathname = nil
        @search = nil
        @hash = nil

    parse: (str, base) =>
        startPos = 1
        endPos = #str

        -- Trim leading and trailing whitespaces
        while byte(str, startPos) <= 0x20 --[[ space ]] do startPos += 1
        while byte(str, endPos) <= 0x20 --[[ space ]] do endPos -= 1

        startPos = @_parseScheme(str, startPos, endPos)
        startPos = @_parseAuthority(str, startPos, endPos)

    _parseScheme: (str, startPos, endPos) =>
        unless isAlpha byte(str, startPos)
            return startPos
        
        doLowerCase = false
        scheme = nil
        for i = startPos, endPos
            ch = byte(str, i)
            if ch == 0x3A -- ':'
                scheme = sub(str, startPos, i - 1)
                if doLowerCase
                    scheme = lower(scheme)
                @scheme = scheme
                return i + 1
            elseif isUpper(ch)
                doLowerCase = true
            elseif not isLower(ch) and ch != 0x2B --[['+']] and ch != 0x2D --[['-']] and ch != 0x2E --[['.']]
                -- scheme have an invalid character, so it's not a scheme
                break
    
        return startPos
    
    _parseAuthority: (str, startPos, endPos) =>
        scheme = @scheme
        if not scheme
            -- no scheme start
            return startPos
    
        isSpecial = SPECIAL_SCHEMAS[scheme]
        -- TODO check for base
        -- TODO special handling for file:
        if isSpecial
            -- special authority slashes
            if byte(str, startPos) == 0x2F --[['/']] and byte(str, startPos + 1) == 0x2F --[['/']]
                startPos += 2

            -- special authority ignore slashes
            while startPos <= endPos
                ch = byte(str, startPos)
                if ch != 0x2F --[['/']] and ch != 0x5C --[['\']]
                    break
                startPos += 1
        elseif byte(str, startPos) == 0x2F --[['/']]
            -- path or authority state
            if byte(str, startPos + 1) != 0x2F --[['/']]
                -- path state
                return startPos
            -- authority state
            startPos += 2
        else
            -- opaque path state
            return startPos

        -- authority state
        atSignSeen = false
        passwordTokenSeen = false
        for i = startPos, endPos
            ch = byte(str, i)
            if ch == 0x2F --[['/']] or ch == 0x3F --[['?']] or ch == 0x23 --[['#']] or (isSpecial and ch == 0x5C --[['\']])
                endPos = i - 1
                break
            elseif ch == 0x40 -- '@'
                atSignSeen = i
            elseif ch == 0x3A --[[':']] and not passwordTokenSeen
                passwordTokenSeen = i
        
        -- After @ there is no hostname
        if atSignSeen == endPos
            error "Invalid URL: Missing host"

        if atSignSeen
            if passwordTokenSeen
                @username = encodeURI sub(str, startPos, passwordTokenSeen - 1)
                @password = encodeURI sub(str, passwordTokenSeen + 1, atSignSeen - 1)
            else
                @username = encodeURI sub(str, startPos, atSignSeen - 1)            

        @_parseHost(str, atSignSeen and atSignSeen + 1 or startPos, endPos, isSpecial)
        return endPos + 1

    _parsePort: (str, startPos, endPos, defaultPort) =>
        port = tonumber sub(str, startPos, endPos)
        if not port or (port > 2 ^ 16 - 1) or port < 0
            error "Invalid URL: Invalid port"
        
        if port != defaultPort
            @port = port

    _parseHost: (str, startPos, endPos, isSpecial) =>
        insideBrackets = false
        for i = startPos, endPos
            ch = byte(str, i)
            if ch == 0x3A --[[':']] and not insideBrackets
                if i == startPos
                    error "Invalid URL: Missing host"
            
                @_parsePort(str, i + 1, endPos, isSpecial)

                endPos = i - 1
                break
            elseif ch == 0x5B -- '['
                insideBrackets = true
            elseif ch == 0x5D -- ']'
                insideBrackets = false

        if isSpecial and startPos == endPos
            error "Invalid URL: Missing host"

        if byte(str, startPos) == 0x5B -- '['
            if byte(str, endPos) != 0x5D -- ']'
                error "Invalid URL: IPv6 unclosed"
    
            -- TODO parse ipv6
            @hostname = sub(str, startPos + 1, endPos - 1)
        elseif not isSpecial
            if containsCharacter(str, FORBIDDEN_HOST_CODE_POINTS, startPos, endPos)
                error "Invalid URL: Host invalid code point"

            @hostname = encodeURI sub(str, startPos, endPos)
        else
            domain = decodeURI sub(str, startPos, endPos)
            asciiDomain = encodeURI(domain) -- TODO punycode encode
            
            if containsCharacter(asciiDomain, FORBIDDEN_DOMAIN_CODE_POINTS)
                error "Invalid URL: Domain invalid code point"
            -- TODO ends in a number + ipv4 parsing

            @hostname = domain

URL!\parse("https://google.com/")
