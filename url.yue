--[[
    MIT License

    Copyright (c) 2024 Pika Software

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
--]]
import istable, isnumber, isstring, tostring, tonumber, rawget, rawset, getmetatable from _G
import byte, char, sub, gsub, lower from string

compileCharacterTable = (chars) ->
    result = []
    for v in *chars
        if istable v
            for i = byte(v[1]), byte(v[2])
                result[i] = true
        else
            result[byte(v)] = true
    return result

-- Use result from `compileCharacterTable` in `containsCharacter` as chars
containsCharacter = (str, chars, startPos = 1, endPos = #str) ->
    for i = startPos, endPos
        if chars[byte(str, i)]
            return true
    return false

SPECIAL_SCHEMAS =
    ftp: 21
    file: true -- currently if value is true, then scheme will be treated as file: scheme in the parser
    http: 80
    https: 443
    ws: 80
    wss: 443

FORBIDDEN_HOST_CODE_POINTS = compileCharacterTable [
    "\0", "\t", "\n", "\r"
    " ", "#", "/", ":" 
    "<", ">", "?", "@"
    "[", "\\", "]", "^", "|"
]

FORBIDDEN_DOMAIN_CODE_POINTS = compileCharacterTable [ 
    "\0", "\t", "\n", "\r"
    " ", "#", "/", ":" 
    "<", ">", "?", "@"
    "[", "\\", "]", "^", "|"
    ["\0", "\x1F"], "%", "\x7F"
]

FILE_OTHERWISE_CODE_POINTS = compileCharacterTable [ "/", "\\", "?", "#" ]

DECODE_LOOKUP_TABLE = []
for i = 0x00, 0xFF
    hex = bit.tohex(i, 2)
    DECODE_LOOKUP_TABLE[hex] = char(i)
    DECODE_LOOKUP_TABLE[hex\upper!] = char(i) 

URI_DECODE_SET = {...DECODE_LOOKUP_TABLE}
for i in *[0x2D, 0x2E, 0x21, 0x7E, 0x2A, 0x27, 0x28, 0x29] -- decodeURI doesn't decode these characters: ; / ? : @ & = + $ , #
    hex = bit.tohex(i, 2)
    URI_DECODE_SET[hex] = nil
    URI_DECODE_SET[hex\upper!] = nil

percentDecode = (s, decodeSet) ->
    s = gsub(s, "%%(%x%x)", decodeSet)
    return s

compilePercentEncodeSet = (encodeSet, ...) ->
    -- Lookup table for decoding percent-encoded characters and encoding special characters
    -- Using HEX_TABLE will result in a double speedup compared to using functions
    encodeSet = {...encodeSet} -- copy given encodeSet, so we don't modify it
    for ch in *{...}
        if isstring ch
            ch = byte(ch) -- if string then convert to byte

        if isnumber ch -- just a single character
            encodeSet[char(ch)] = "%" .. bit.tohex(ch, 2)\upper!
        elseif istable ch -- range of characters
            charStart = isstring(ch[1]) and byte(ch[1]) or ch[1]
            charEnd = isstring(ch[2]) and byte(ch[2]) or ch[2]

            for i = charStart, charEnd
                encodeSet[char(i)] = "%" .. bit.tohex(i, 2)\upper!
        
    return encodeSet

percentEncode = (s, encodeSet, spaceAsPlus) ->
    old = nil
    if spaceAsPlus == true
        old = encodeSet[" "]
        encodeSet[" "] = "+"
    s = gsub(s, "%W", encodeSet)
    if old
        encodeSet[" "] = old
    return s

C0_ENCODE_SET = compilePercentEncodeSet({}, [0x00, 0x1F], [0x7F, 0xFF])
FRAGMENT_ENCODE_SET = compilePercentEncodeSet(C0_ENCODE_SET, " ", "\"", "<", ">", "`")
QUERY_ENCODE_SET = compilePercentEncodeSet(C0_ENCODE_SET, " ", "\"", "#", "<", ">")
SPECIAL_QUERY_ENCODE_SET = compilePercentEncodeSet(QUERY_ENCODE_SET, "'")
PATH_ENCODE_SET = compilePercentEncodeSet(QUERY_ENCODE_SET, "?", "`", "{", "}")
USERINFO_ENCODE_SET = compilePercentEncodeSet(PATH_ENCODE_SET, "/", ":", ";", "=", "@", [0x5B, 0x5E], "|")
COMPONENT_ENCODE_SET = compilePercentEncodeSet(USERINFO_ENCODE_SET, [0x24, 0x26], "+", ",")
URLENCODED_ENCODE_SET = compilePercentEncodeSet(COMPONENT_ENCODE_SET, "!", [0x27, 0x29], "~")
URI_ENCODE_SET = compilePercentEncodeSet(C0_ENCODE_SET, 0x20, 0x22, 0x25, 0x3C, 0x3E, [0x42, 0x59], [0x5B, 0x5E], 0x60, [0x62, 0x79], [0x7B, 0x7D])

export encodeURI = (s) -> percentEncode(s, URI_ENCODE_SET)
export encodeURIComponent = (s) -> percentEncode(s, COMPONENT_ENCODE_SET, true)
export decodeURIComponent = (s) -> percentDecode(s, DECODE_LOOKUP_TABLE)
export decodeURI = (s) -> percentDecode(s, URI_DECODE_SET)

isLower = (ch) -> ch >= 0x61 --[['a']] and ch <= 0x7A --[['z']]
isUpper = (ch) -> ch >= 0x41 --[['A']] and ch <= 0x5A --[['Z']]
isAlpha = (ch) -> isLower(ch) or isUpper(ch)
isDigit = (ch) -> ch >= 0x30 --[['0']] and ch <= 0x39 --[['9']]
isSingleDot = (str) ->
    return switch #str
        when 1 then str == "."
        when 3 then lower(str) == "%2e"
        else false
isDoubleDot = (str) ->
    return switch #str
        when 2 then str == ".."
        when 4
            str = lower(str)
            str == "%2e." or str == ".%2e"
        when 6 then lower(str) == "%2e%2e"
        else false
isWindowsDriveLetterCodePoints = (ch1, ch2, normalized) -> isAlpha(ch1) and (ch2 == 0x3A --[[':']] or (normalized == false and ch2 == 0x7C --[['|']]))
isWindowsDriveLetter = (str, normalized) -> return #str == 2 and isWindowsDriveLetterCodePoints(byte(str, 1), byte(str, 2), normalized)
startsWithWindowsDriveLetter = (str, startPos, endPos) ->
    len = endPos - startPos + 1
    return len > 2 and 
        isWindowsDriveLetterCodePoints(byte(str, startPos), byte(str, startPos + 1)) and
        (len == 2 or FILE_OTHERWISE_CODE_POINTS[byte(str, startPos + 2)])

-- Finds nearest non whitespace character from startPos to endPos
-- And returns the position of that character
trimInput = (str, startPos, endPos) ->
    for i = startPos, endPos, (startPos < endPos and 1 or -1)
        ch = byte(str, i)
        if not ch --[[ EOF ]] or ch > 0x20 --[[ C0 control or space ]]
            return i
    return endPos - 1

parseHostString = (str, startPos, endPos, isSpecial) ->
    if byte(str, startPos) == 0x5B -- '['
        if byte(str, endPos) != 0x5D -- ']'
            error "Invalid URL: IPv6 unclosed"

        -- TODO parse ipv6
        return sub(str, startPos + 1, endPos - 1)
    elseif not isSpecial
        -- opaque host parsing
        if containsCharacter(str, FORBIDDEN_HOST_CODE_POINTS, startPos, endPos)
            error "Invalid URL: Host invalid code point"

        return percentEncode(sub(str, startPos, endPos), C0_ENCODE_SET)
    else
        domain = percentDecode(sub(str, startPos, endPos), DECODE_LOOKUP_TABLE)
        asciiDomain = percentEncode(domain, C0_ENCODE_SET) -- TODO punycode encode
        
        if containsCharacter(asciiDomain, FORBIDDEN_DOMAIN_CODE_POINTS)
            error "Invalid URL: Domain invalid code point"
        -- TODO ends in a number + ipv4 parsing

        return domain

-- Predefine locals so we can make functions in the order I want (as if you were reading specs)
local parseScheme, parseNoScheme, parseSpecialRelativeOrAuthority, parsePathOrAuthority
local parseRelative, parseRelativeSlash, parseSpecialAuthorityIgnoreSlashes, parseAuthority
local parseHost, parsePort, parseFile, parseFileSlash, parseFileHost, parsePathStart, parsePath, parseOpaquePath
local parseQuery, parseFragment

parseScheme = (str, startPos, endPos, base) =>
    -- scheme start state
    if isAlpha byte(str, startPos)
        -- scheme state
        doLowerCase = false
        scheme = nil
        for i = startPos, endPos
            ch = byte(str, i)
            if ch == 0x3A -- ':'
                scheme = sub(str, startPos, i - 1)
                if doLowerCase
                    scheme = lower(scheme)
                @scheme = scheme

                isSpecial = SPECIAL_SCHEMAS[scheme]
                if isSpecial == true -- scheme is file:
                    -- file state
                    parseFile(@, str, i + 1, endPos, base)
                elseif isSpecial and base and base.scheme == scheme
                    -- special relative or authority state
                    parseSpecialRelativeOrAuthority(@, str, i + 1, endPos, base, isSpecial)
                elseif isSpecial
                    -- special authority slashes state
                    parseSpecialAuthorityIgnoreSlashes(@, str, i + 1, endPos, base, isSpecial) -- anyway state will ignore slashes
                elseif byte(str, i + 1) == 0x2F --[['/']]
                    -- path or authority state
                    parsePathOrAuthority(@, str, i + 2, endPos, base)
                else
                    -- opaque path state
                    parseOpaquePath(@, str, i + 1, endPos)
                return
            elseif isUpper(ch)
                doLowerCase = true
            elseif not isLower(ch) and ch != 0x2B --[['+']] and ch != 0x2D --[['-']] and ch != 0x2E --[['.']]
                -- scheme have an invalid character, so it's not a scheme
                break

    -- no scheme state
    parseNoScheme(@, str, startPos, endPos, base)
    

parseNoScheme = (str, startPos, endPos, base) =>
    startsWithFragment = byte(str, startPos) == 0x23 --[['#']]
    baseHasOpaquePath = base and isstring(base.path)
    if not base or (baseHasOpaquePath and not startsWithFragment)
        error "Invalid URL: Missing scheme"

    if baseHasOpaquePath and startsWithFragment
        @scheme = base.scheme
        @path = base.path
        @query = base.query
        parseFragment(@, str, startPos + 1, endPos)
    elseif base.scheme != "file"
        parseRelative(@, str, startPos, endPos, base)
    else
        @scheme = "file"
        parseFile(@, str, startPos, endPos, base)

parseSpecialRelativeOrAuthority = (str, startPos, endPos, base, isSpecial) =>
    if byte(str, startPos) == 0x2F --[['/']] and byte(str, startPos + 1) == 0x2F --[['/']]
        -- special authority slashes state
        parseSpecialAuthorityIgnoreSlashes(@, str, startPos + 2, endPos, base, isSpecial)
    else
        -- relative state
        @scheme = base.scheme
        parseRelative(@, str, startPos, endPos, base, isSpecial)

parsePathOrAuthority = (str, startPos, endPos, base) =>
    if byte(str, startPos) == 0x2F --[['/']]
        parseAuthority(@, str, startPos + 1, endPos)
    else
        parsePath(@, str, startPos, endPos)

parseRelative = (str, startPos, endPos, base, isSpecial) =>
    ch = byte(str, startPos)
    if ch == 0x2F --[['/']] or (isSpecial and ch == 0x5C --[['\']])
        -- relative slash state
        parseRelativeSlash(@, str, startPos + 1, endPos, base, isSpecial)
    else
        @username = base.username
        @password = base.password
        @hostname = base.hostname
        @port = base.port
        path = @path = {...base.path} -- clone path
        if ch == 0x3F --[['?']]
            parseQuery(@, str, startPos + 1, endPos)
        elseif ch == 0x23 --[['#']]
            @query = base.query
            parseFragment(@, str, startPos + 1, endPos)
        elseif ch -- not EOF
            pathLen = #path
            if pathLen != 1 or not isWindowsDriveLetter(path[1])
                path[pathLen] = nil -- removing last path segment
            parsePath(@, str, startPos, endPos, isSpecial, path)


parseRelativeSlash = (str, startPos, endPos, base, isSpecial) =>
    ch = byte(str, startPos)
    if isSpecial and (ch == 0x2F --[['/']] or ch == 0x5C --[['\']])
        -- special authority ignore slashes state
        parseSpecialAuthorityIgnoreSlashes(@, str, startPos + 1, endPos, base, isSpecial)
    elseif ch == 0x2F --[['/']]
        -- authority state
        parseAuthority(@, str, startPos + 1, endPos, isSpecial)
    else
        @username = base.username
        @password = base.password
        @hostname = base.hostname
        @port = base.port
        parsePath(@, str, startPos, endPos, isSpecial)

parseSpecialAuthorityIgnoreSlashes = (str, startPos, endPos, base, isSpecial) =>
    for i = startPos, endPos
        ch = byte(str, i)
        if ch != 0x2F --[['/']] and ch != 0x5C --[['\']]
            parseAuthority(@, str, i, endPos, isSpecial)

parseAuthority = (str, startPos, endPos, isSpecial) =>
    -- authority state
    atSignSeen = false
    passwordTokenSeen = false
    for i = startPos, endPos
        ch = byte(str, i)
        if ch == 0x2F --[['/']] or ch == 0x3F --[['?']] or ch == 0x23 --[['#']] or (isSpecial and ch == 0x5C --[['\']])
            endPos = i - 1
            break
        elseif ch == 0x40 -- '@'
            atSignSeen = i
        elseif ch == 0x3A --[[':']] and not passwordTokenSeen
            passwordTokenSeen = i
    
    -- After @ there is no hostname
    if atSignSeen == endPos
        error "Invalid URL: Missing host"

    if atSignSeen
        if passwordTokenSeen
            @username = percentEncode(sub(str, startPos, passwordTokenSeen - 1), USERINFO_ENCODE_SET)
            @password = percentEncode(sub(str, passwordTokenSeen + 1, atSignSeen - 1), USERINFO_ENCODE_SET)
        else
            @username = percentEncode(sub(str, startPos, atSignSeen - 1), USERINFO_ENCODE_SET)

    parseHost(@, str, atSignSeen and atSignSeen + 1 or startPos, endPos, isSpecial)
    parsePathStart(@, str, endPos + 1, endPos, isSpecial)

parseHost = (str, startPos, endPos, isSpecial) =>
    insideBrackets = false
    for i = startPos, endPos
        ch = byte(str, i)
        if ch == 0x3A --[[':']] and not insideBrackets
            if i == startPos
                error "Invalid URL: Missing host"
        
            parsePort(@, str, i + 1, endPos, isSpecial)

            endPos = i - 1
            break
        elseif ch == 0x5B -- '['
            insideBrackets = true
        elseif ch == 0x5D -- ']'
            insideBrackets = false

    if isSpecial and startPos == endPos
        error "Invalid URL: Missing host"

    @hostname = parseHostString(str, startPos, endPos, isSpecial)

parsePort = (str, startPos, endPos, defaultPort) =>
    port = tonumber sub(str, startPos, endPos)
    if not port or (port > 2 ^ 16 - 1) or port < 0
        error "Invalid URL: Invalid port"
    
    if port != defaultPort
        @port = port

parseFile = (str, startPos, endPos, base) =>
    ch = byte(str, startPos)
    if ch == 0x2F --[['/']] or ch == 0x5C --[['\']]
        parseFileSlash(@, str, startPos + 1, endPos, base)
    elseif base and base.scheme == "file"
        @hostname = base.hostname
        path = @path = {...base.path}
        if ch == 0x3F --[['?']]
            parseQuery(@, str, startPos + 1, endPos)
        elseif ch == 0x23 --[['#']]
            @query = base.query
            parseFragment(@, str, startPos + 1, endPos)
        elseif ch -- not EOF
            pathLen = #path
            if not startsWithWindowsDriveLetter(str, startPos, endPos)
                if pathLen != 1 or not isWindowsDriveLetter(path[1])
                    path[pathLen] = nil -- removing last path segment
            else
                path = nil
            parsePath(@, str, startPos, endPos, true, path)
    else
        parsePath(@, str, startPos, endPos, true)

parseFileSlash = (str, startPos, endPos, base) =>
    ch = byte(str, startPos)
    if ch == 0x2F --[['/']] or ch == 0x5C --[['\']]
        parseFileHost(@, str, startPos + 1, endPos)
    else
        path = {}
        if base and base.scheme == "file"
            @hostname = base.hostname
            if not startsWithWindowsDriveLetter(str, startPos, endPos) and isWindowsDriveLetter(base.path[1], false)
                path[1] = base.path[1]
        parsePath(@, str, startPos, endPos, true, path)

parseFileHost = (str, startPos, endPos) =>
    i = startPos
    while true
        ch = byte(str, i)
        if ch == 0x2F --[['/']] or ch == 0x5C --[['\']] or ch == 0x3F --[['?']] or ch == 0x23 --[['#']] or not ch -- EOF
            hostLen = i - startPos
            if hostLen == 2 and isWindowsDriveLetterCodePoints(byte(str, startPos), byte(str, startPos + 1), false)
                parsePath(@, str, startPos, endPos, true)
            elseif hostLen == 0
                @hostname = ""
                parsePathStart(@, str, i, endPos, true)
            else
                hostname = parseHostString(str, startPos, i - 1, false)
                if hostname == "localhost"
                    hostname = ""
                
                @hostname = hostname
                parsePathStart(@, str, i, endPos, true)
            break
        i += 1

parsePathStart = (str, startPos, endPos, isSpecial) =>
    ch = byte(str, startPos)
    if isSpecial
        if ch == 0x2F --[['/']] or ch == 0x5C --[['\']]
            startPos += 1
        parsePath(@, str, startPos, endPos, isSpecial)
    elseif ch == 0x3F --[['?']]
        parseQuery(@, str, startPos + 1, endPos)
    elseif ch == 0x23 --[['#']]
        parseFragment(@, str, startPos + 1, endPos)
    elseif ch -- not EOF
        if ch == 0x2F --[['/']]
            startPos += 1
        parsePath(@, str, startPos, endPos, isSpecial)

parsePath = (str, startPos, endPos, isSpecial, segments={}) =>
    hasWindowsLetter = false
    segmentsCount = #segments
    segmentStart = startPos

    i = startPos
    while true
        ch = byte(str, i)
        if ch == 0x2F --[['/']] or (isSpecial and ch == 0x5C --[['\']]) or ch == 0x3F --[['?']] or ch == 0x23 --[['#']] or not ch -- EOF
            segment = percentEncode(sub(str, segmentStart, i - 1), PATH_ENCODE_SET)
            segmentStart = i + 1
            if isDoubleDot(segment)
                if segmentsCount != 1 or not hasWindowsLetter
                    segments[segmentsCount] = nil
                    segmentsCount -= 1
            elseif not isSingleDot(segment)
                if isSpecial == true --[[is file scheme]] and segmentsCount == 0 and isWindowsDriveLetter(segment, false)
                    segment = gsub(segment, "|", ":")
                    hasWindowsLetter = true
                segmentsCount += 1
                segments[segmentsCount] = segment

            if ch == 0x3F --[['?']]
                parseQuery(@, str, i + 1, endPos)
                break
            elseif ch == 0x23 --[['#']]
                parseFragment(@, str, i + 1, endPos)
                break
            elseif not ch
                break

        i += 1

    @path = segments

parseOpaquePath = (str, startPos, endPos) =>
    for i = startPos, endPos
        ch = byte(str, i)
        if ch == 0x3F --[['?']]
            parseQuery(@, str, i + 1, endPos)
            endPos = i - 1
            break
        elseif ch == 0x23 --[['#']]
            parseFragment(@, str, i + 1, endPos)
            endPos = i - 1
            break

    @path = percentEncode(sub(str, startPos, endPos), C0_ENCODE_SET)

parseQuery = (str, startPos, endPos, isSpecial) =>
    for i = startPos, endPos
        if byte(str, i) == 0x23 --[['#']]
            parseFragment(@, str, i + 1, endPos)
            endPos = i - 1
            break

    encodeSet = isSpecial and SPECIAL_QUERY_ENCODE_SET or QUERY_ENCODE_SET
    @query = percentEncode(sub(str, startPos, endPos), encodeSet)

parseFragment = (str, startPos, endPos) =>
    @fragment = percentEncode(sub(str, startPos, endPos), FRAGMENT_ENCODE_SET)

parse = (str, base) =>
    unless isstring str
        error "Invalid URL: URL must be a string"
    
    if isstring base
        -- yeah, we dont even need to full URL object for this
        url = {}
        parse(url, base)
        base = url

    str = gsub(str, "[\t\n\r]", "") -- remove all tab and newline characters
    startPos = 1
    endPos = #str

    -- Trim leading and trailing whitespaces
    startPos = trimInput(str, startPos, endPos)
    endPos = trimInput(str, endPos, startPos)

    if startPos > endPos
        error "Invalid URL: Empty URL"

    parseScheme(@, str, startPos, endPos, base)

    -- scheme = @scheme
    -- isSpecial = scheme and SPECIAL_SCHEMAS[@scheme]

    -- if scheme
    --     startPos = parseAuthority(@, str, startPos, endPos, isSpecial)

    -- ch = byte(str, startPos)
    -- -- path start state
    -- if ch == 0x2F --[['/']] or (isSpecial and ch == 0x5C --[['\']])
    --     -- path state
    --     parsePath(@, str, startPos + 1, endPos, isSpecial)
    -- elseif ch == 0x3F --[['?']]
    --     -- query state
    --     parseQuery(@, str, startPos + 1, endPos)
    -- elseif ch == 0x23 --[['#']]
    --     -- fragment state
    --     parseFragment(@, str, startPos + 1, endPos)
    -- elseif not isSpecial and ch -- any char
    --     -- opaque path state
    --     parseOpaquePath(@, str, startPos, endPos)

class URL
    new: (str, base) =>
        parse(@, str, base)

    parse: parse
    @parse: (str, base) -> URL(str, base)

PrintTable URL("a", "file:/addons/gm_url/test/library/")
